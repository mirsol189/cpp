#include <iostream>

// Step 7. 자료구조의 변경 
//		   Stack 사용자가 버퍼 크기 변경가능하게
//         배열 => 동적 메모리 할당
//		   소멸자 도입, 객체 파괴시 객체가 사용하던 자원 반납

// 그런데, "Stack 클래스 사용자는 자신이 얼만큼의 데이타를 push 할지 알수 있었을까요 ?
// ==> 알수 없을때도 많이 있습니다
// ==> 그래서 내부 자료구조를 "linked list" 로 하는 경우도 많습니다.

// 기본적으로 "생성자/소멸자"는 자동으로 호출되는게 원칙 입니다.
// 물론, 고급 기법으로 "명시적으로 호출하는 기술도 있습니다." 


class Stack
{
private:
	int* buff;
	int  idx;

public:
	Stack(int size = 10) 
	{
		idx = 0; 
		buff = new int[size];
	}

	// 소멸자 : "~클래스이름" 모양의 함수
	//		   객체가 파괴 될때 자동으로 호출된다.
	//		   반드시 만들 필요는 없고 필요할때만 만들면 된다.
	~Stack()
	{
		// 생성자에서 획득한 자원이 있으면 여기서 반납한다.
		delete[] buff; // 배열(1차, 2차, 다차 모두)로 할당한 경우는 "delete[]"
					   // 배열이 아니면 "delete"
					   // 통일할수 없었나요 ?? => 성능이슈로 분리되어 있습니다.

		//
	}


	void push(int value) { buff[idx++] = value; }
	int pop() { return buff[--idx]; }
};

int main()
{
//	Stack s1;		// 이렇게 생성하면 size 는 디폴트값 10
	Stack s1(20);	// 이렇게 하면 생성자인자에 20이 전달됩니다.
//	s1.Stack(); // 생성자는 이렇게 부를수 없습니다.
			    // new(&s1) Stack; 이런 기술이 있긴 하지만.. 

	s1.push(10);
	s1.push(20);

	std::cout << s1.pop() << std::endl;

	// QA : 소멸자도 public 에 있는 함수이니까. 명시적으로 호출할수 있나요 ?
	//    => 네 가능합니다
	//    => 초급시절에는 거의 사용안하지만.. 중고급 코드에서는 아주 널리사용됩니다.
//	s1.~Stack(); 
}







